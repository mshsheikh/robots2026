"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_course=globalThis.webpackChunkphysical_ai_humanoid_robotics_course||[]).push([[523],{8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>o});var s=i(6540);const r={},t=s.createContext(r);function a(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(t.Provider,{value:n},e.children)}},8816:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"week6-manipulation-knowledge","title":"Week 6: Manipulation and Grasping","description":"Introduction to Robotic Manipulation","source":"@site/docs/week6-manipulation-knowledge.md","sourceDirName":".","slug":"/week6-manipulation-knowledge","permalink":"/robots2026/docs/week6-manipulation-knowledge","draft":false,"unlisted":false,"editUrl":"https://github.com/mshsheikh/ai-humanoid-robotics/tree/master/docs/week6-manipulation-knowledge.md","tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"sidebar_position":7},"sidebar":"tutorialSidebar","previous":{"title":"Week 5: Bipedal Locomotion Principles","permalink":"/robots2026/docs/week5-bipedal-locomotion"},"next":{"title":"Week 7: Humanoid Robot Hardware Design","permalink":"/robots2026/docs/week7-humanoid-hardware"}}');var r=i(4848),t=i(8453);const a={sidebar_position:7},o="Week 6: Manipulation and Grasping",l={},c=[{value:"Introduction to Robotic Manipulation",id:"introduction-to-robotic-manipulation",level:2},{value:"Learning Paths by Experience Level",id:"learning-paths-by-experience-level",level:2},{value:"Newbie in Tech",id:"newbie-in-tech",level:3},{value:"What Manipulation Means in Robotics",id:"what-manipulation-means-in-robotics",level:4},{value:"Hands vs Grippers Explained Simply",id:"hands-vs-grippers-explained-simply",level:4},{value:"Object Properties (Shape, Weight, Fragility)",id:"object-properties-shape-weight-fragility",level:4},{value:"Everyday Examples (Picking up a Cup)",id:"everyday-examples-picking-up-a-cup",level:4},{value:"Learning Objectives",id:"learning-objectives",level:4},{value:"Conceptual Activities",id:"conceptual-activities",level:4},{value:"Glossary of Key Terms",id:"glossary-of-key-terms",level:4},{value:"Junior / Beginner",id:"junior--beginner",level:3},{value:"Learning Objectives",id:"learning-objectives-1",level:4},{value:"Grasp Types (Power vs Precision)",id:"grasp-types-power-vs-precision",level:4},{value:"Basic Kinematics Intuition",id:"basic-kinematics-intuition",level:4},{value:"Perception-to-Grasp Pipeline",id:"perception-to-grasp-pipeline",level:4},{value:"Guided Grasp-Planning Exercise",id:"guided-grasp-planning-exercise",level:4},{value:"Common Mistakes",id:"common-mistakes",level:4},{value:"Mid-Level Engineer",id:"mid-level-engineer",level:3},{value:"Learning Objectives",id:"learning-objectives-2",level:4},{value:"Forward/Inverse Kinematics",id:"forwardinverse-kinematics",level:4},{value:"Grasp Synthesis Basics",id:"grasp-synthesis-basics",level:4},{value:"Symbolic vs Geometric Representations",id:"symbolic-vs-geometric-representations",level:4},{value:"Task and Motion Planning (TAMP)",id:"task-and-motion-planning-tamp",level:4},{value:"Code Snippets",id:"code-snippets",level:4},{value:"Challenge Problems",id:"challenge-problems",level:4},{value:"Senior / Executive",id:"senior--executive",level:3},{value:"Learning Objectives",id:"learning-objectives-3",level:4},{value:"Manipulation Stack Architecture",id:"manipulation-stack-architecture",level:4},{value:"Data-Driven vs Model-Based Trade-offs",id:"data-driven-vs-model-based-trade-offs",level:4},{value:"Reliability and Failure Modes",id:"reliability-and-failure-modes",level:4},{value:"Sim-to-Real and Dataset Concerns",id:"sim-to-real-and-dataset-concerns",level:4},{value:"Deployment Checklist",id:"deployment-checklist",level:4}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"week-6-manipulation-and-grasping",children:"Week 6: Manipulation and Grasping"})}),"\n",(0,r.jsx)(n.h2,{id:"introduction-to-robotic-manipulation",children:"Introduction to Robotic Manipulation"}),"\n",(0,r.jsx)(n.p,{children:"This week covers the essential concepts of manipulation and grasping for humanoid robots."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Kinematics and Dynamics"}),": Forward and inverse kinematics for multi-link arms, Jacobian matrices, and dynamic modeling for manipulation tasks."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Grasping Strategies"}),": Analysis of different grasp types, grasp planning algorithms, and force distribution for stable object manipulation."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Task Execution"}),": Coordinated manipulation tasks including pick-and-place, tool use, and bimanual manipulation using both arms simultaneously."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"This knowledge enables humanoid robots to interact effectively with objects in their environment for complex manipulation tasks."}),"\n",(0,r.jsx)(n.h2,{id:"learning-paths-by-experience-level",children:"Learning Paths by Experience Level"}),"\n",(0,r.jsx)(n.h3,{id:"newbie-in-tech",children:"Newbie in Tech"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Audience"}),": Complete beginner"]}),"\n",(0,r.jsx)(n.h4,{id:"what-manipulation-means-in-robotics",children:"What Manipulation Means in Robotics"}),"\n",(0,r.jsx)(n.p,{children:'Manipulation in robotics refers to the ability of a robot to interact with and control objects in its environment. This includes picking up, moving, repositioning, and releasing objects. Think of it as the robot\'s ability to use its "hands" (or end effectors) to perform tasks similar to how humans use their hands to manipulate objects around them.'}),"\n",(0,r.jsx)(n.h4,{id:"hands-vs-grippers-explained-simply",children:"Hands vs Grippers Explained Simply"}),"\n",(0,r.jsx)(n.p,{children:'Robotic "hands" are more complex and can have multiple fingers with many joints, similar to human hands. They can perform various types of grasps but are more complex to control. Robotic "grippers" are simpler devices with typically 2-3 fingers or pads that can open and close to grasp objects. They\'re less versatile than hands but more reliable and easier to control.'}),"\n",(0,r.jsx)(n.h4,{id:"object-properties-shape-weight-fragility",children:"Object Properties (Shape, Weight, Fragility)"}),"\n",(0,r.jsx)(n.p,{children:"For successful manipulation, robots need to understand object properties:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Shape"}),": Determines how to approach and grasp the object"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Weight"}),": Affects how much force to apply during grasping"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Fragility"}),": Dictates how gently or firmly to grasp"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Material"}),": Influences friction and grip requirements"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Size"}),": Determines appropriate grasp type and approach angle"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"everyday-examples-picking-up-a-cup",children:"Everyday Examples (Picking up a Cup)"}),"\n",(0,r.jsx)(n.p,{children:"When you pick up a cup, you instinctively know to grasp it by the handle with just enough force to hold it without dropping it or crushing it. You consider its weight, whether it's full or empty, and its shape. A robot must be programmed with similar understanding to perform this task reliably."}),"\n",(0,r.jsx)(n.h4,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Understand what robotic manipulation means and why it's important"}),"\n",(0,r.jsx)(n.li,{children:"Distinguish between different types of end effectors (hands vs grippers)"}),"\n",(0,r.jsx)(n.li,{children:"Recognize how object properties affect manipulation strategies"}),"\n",(0,r.jsx)(n.li,{children:"Appreciate the complexity of human-like manipulation tasks"}),"\n",(0,r.jsx)(n.li,{children:"Identify common manipulation tasks in everyday life"}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"conceptual-activities",children:"Conceptual Activities"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Grasp Analysis"})," (Time estimate: 20-25 minutes)"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Observe how you pick up different objects (pencil, book, cup, ball)"}),"\n",(0,r.jsx)(n.li,{children:"Notice the different grasp types you naturally use for each object"}),"\n",(0,r.jsx)(n.li,{children:"Consider how the object's properties influence your grasp choice"}),"\n",(0,r.jsx)(n.li,{children:'Think about how a robot might need to "think" about these choices'}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Manipulation in Daily Life"})," (Time estimate: 25-30 minutes)"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"List 10 common manipulation tasks you perform daily"}),"\n",(0,r.jsx)(n.li,{children:"For each task, identify the object properties that are important"}),"\n",(0,r.jsx)(n.li,{children:"Consider which tasks would be challenging for a robot"}),"\n",(0,r.jsx)(n.li,{children:"Reflect on the perception and control requirements for each task"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Failure Modes Exploration"})," (Time estimate: 30-35 minutes)"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Think about times when you've dropped or mishandled objects"}),"\n",(0,r.jsx)(n.li,{children:"Consider what went wrong (too much force, wrong grasp, etc.)"}),"\n",(0,r.jsx)(n.li,{children:"Imagine how a robot might detect and recover from similar failures"}),"\n",(0,r.jsx)(n.li,{children:"Consider how robots might prevent such failures"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"glossary-of-key-terms",children:"Glossary of Key Terms"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Manipulation"}),": The process of controlling and moving objects using a robot's end effector"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"End Effector"}),": The device at the end of a robot arm used for grasping and manipulating objects"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Grasp"}),": The act of securely holding an object with sufficient force to control it"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Kinematics"}),": The study of motion without considering the forces that cause it"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Forward Kinematics"}),": Calculating the end effector position from joint angles"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Inverse Kinematics"}),": Calculating joint angles needed to achieve a desired end effector position"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Grasp Planning"}),": Determining the optimal way to grasp an object"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Task and Motion Planning"}),": Coordinating high-level task planning with low-level motion planning"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"junior--beginner",children:"Junior / Beginner"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Audience"}),": Early robotics learner"]}),"\n",(0,r.jsx)(n.h4,{id:"learning-objectives-1",children:"Learning Objectives"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Distinguish between power and precision grasp types"}),"\n",(0,r.jsx)(n.li,{children:"Understand basic kinematics concepts and their importance"}),"\n",(0,r.jsx)(n.li,{children:"Explain the perception-to-grasp pipeline"}),"\n",(0,r.jsx)(n.li,{children:"Apply basic grasp planning principles"}),"\n",(0,r.jsx)(n.li,{children:"Identify common manipulation challenges"}),"\n",(0,r.jsx)(n.li,{children:"Connect manipulation concepts to perception systems from Week 3"}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"grasp-types-power-vs-precision",children:"Grasp Types (Power vs Precision)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Power Grasps"})," involve wrapping the fingers around an object to apply significant forces. These are used for lifting heavy objects or applying strong forces. Examples include cylindrical grasps for holding tools or spherical grasps for holding balls."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Precision Grasps"})," use just the fingertips to hold objects with fine control. These are used for delicate tasks requiring precise positioning. Examples include the pinch grasp for picking up small objects or the tip pinch for very fine manipulation."]}),"\n",(0,r.jsx)(n.h4,{id:"basic-kinematics-intuition",children:"Basic Kinematics Intuition"}),"\n",(0,r.jsx)(n.p,{children:"Kinematics describes the motion of the robot arm without considering the forces that cause the motion. Forward kinematics calculates where the end effector will be based on the joint angles. Inverse kinematics calculates what joint angles are needed to position the end effector at a specific location."}),"\n",(0,r.jsx)(n.p,{children:"For manipulation, kinematics is crucial because the robot must know where its hand is in space relative to objects in the environment."}),"\n",(0,r.jsx)(n.h4,{id:"perception-to-grasp-pipeline",children:"Perception-to-Grasp Pipeline"}),"\n",(0,r.jsx)(n.p,{children:"The manipulation pipeline typically follows these stages:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Object Detection"}),": Identify objects of interest in the environment"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Pose Estimation"}),": Determine the position and orientation of objects"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Grasp Planning"}),": Select optimal grasp points and configurations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Motion Planning"}),": Plan collision-free paths to reach the grasp"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Grasp Execution"}),": Execute the grasp with appropriate forces"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Post-grasp Verification"}),": Confirm successful grasp and object stability"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"guided-grasp-planning-exercise",children:"Guided Grasp-Planning Exercise"}),"\n",(0,r.jsx)(n.p,{children:"Consider the steps to plan a grasp for a simple object:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"# Basic grasp planning algorithm\r\nfunction planGrasp(object_pose, object_properties):\r\n    # 1. Analyze object geometry and properties\r\n    geometry = analyzeObjectGeometry(object_pose, object_properties)\r\n\r\n    # 2. Generate candidate grasp points\r\n    grasp_candidates = generateGraspPoints(geometry)\r\n\r\n    # 3. Evaluate grasp quality for each candidate\r\n    valid_grasps = []\r\n    for candidate in grasp_candidates:\r\n        if isValidGrasp(candidate, geometry):\r\n            quality = evaluateGraspQuality(candidate, geometry)\r\n            if quality > threshold:\r\n                valid_grasps.append((candidate, quality))\r\n\r\n    # 4. Select best grasp based on quality and accessibility\r\n    best_grasp = selectOptimalGrasp(valid_grasps)\r\n\r\n    # 5. Plan approach trajectory to avoid collisions\r\n    approach_path = planApproachTrajectory(best_grasp)\r\n\r\n    return best_grasp, approach_path\n"})}),"\n",(0,r.jsx)(n.h4,{id:"common-mistakes",children:"Common Mistakes"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Not considering object mass when planning grasp forces"}),"\n",(0,r.jsx)(n.li,{children:"Ignoring collision constraints during approach and withdrawal"}),"\n",(0,r.jsx)(n.li,{children:"Failing to account for sensor noise in object pose estimation"}),"\n",(0,r.jsx)(n.li,{children:"Using inappropriate grasp types for object properties"}),"\n",(0,r.jsx)(n.li,{children:"Not planning for potential grasp failures or re-grasping"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"mid-level-engineer",children:"Mid-Level Engineer"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Audience"}),": Practicing roboticist"]}),"\n",(0,r.jsx)(n.h4,{id:"learning-objectives-2",children:"Learning Objectives"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Apply forward and inverse kinematics to manipulation problems"}),"\n",(0,r.jsx)(n.li,{children:"Implement grasp synthesis algorithms"}),"\n",(0,r.jsx)(n.li,{children:"Compare symbolic and geometric knowledge representations"}),"\n",(0,r.jsx)(n.li,{children:"Design task and motion planning (TAMP) solutions"}),"\n",(0,r.jsx)(n.li,{children:"Integrate perception and manipulation systems effectively"}),"\n",(0,r.jsx)(n.li,{children:"Evaluate manipulation performance quantitatively"}),"\n",(0,r.jsx)(n.li,{children:"Handle manipulation system implementation challenges"}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"forwardinverse-kinematics",children:"Forward/Inverse Kinematics"}),"\n",(0,r.jsx)(n.p,{children:"Forward kinematics (FK) computes the end-effector pose given joint angles:\r\nx = f(\u03b8\u2081, \u03b8\u2082, ..., \u03b8\u2099)"}),"\n",(0,r.jsx)(n.p,{children:"For a simple 2D planar arm with joint angles \u03b8\u2081, \u03b8\u2082, and link lengths l\u2081, l\u2082:\r\nx = l\u2081cos(\u03b8\u2081) + l\u2082cos(\u03b8\u2081 + \u03b8\u2082)\r\ny = l\u2081sin(\u03b8\u2081) + l\u2082sin(\u03b8\u2081 + \u03b8\u2082)"}),"\n",(0,r.jsx)(n.p,{children:"Inverse kinematics (IK) computes joint angles given desired end-effector pose:\r\n\u03b8 = f\u207b\xb9(x, y, z, \u03c6, \u03b8, \u03c8)"}),"\n",(0,r.jsx)(n.p,{children:"IK solutions can be analytical for simple robots or numerical for complex ones."}),"\n",(0,r.jsx)(n.h4,{id:"grasp-synthesis-basics",children:"Grasp Synthesis Basics"}),"\n",(0,r.jsx)(n.p,{children:"Grasp synthesis involves generating and evaluating potential grasp configurations. Key considerations include:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Force closure: The grasp can resist arbitrary external forces"}),"\n",(0,r.jsx)(n.li,{children:"Form closure: The grasp geometry alone provides stability"}),"\n",(0,r.jsx)(n.li,{children:"Grasp quality metrics: Quantitative measures of grasp stability"}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"symbolic-vs-geometric-representations",children:"Symbolic vs Geometric Representations"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Symbolic representations"})," use abstract, discrete symbols to represent knowledge about objects and tasks. They're good for high-level reasoning but require mapping to geometric information for manipulation."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Geometric representations"})," use continuous, spatial information about object shapes, poses, and spatial relationships. They're essential for precise manipulation but can be computationally expensive."]}),"\n",(0,r.jsx)(n.h4,{id:"task-and-motion-planning-tamp",children:"Task and Motion Planning (TAMP)"}),"\n",(0,r.jsx)(n.p,{children:"TAMP integrates high-level task planning with low-level motion planning. The challenge is that task plans need geometric feasibility verification, while motion plans need to respect task-level constraints."}),"\n",(0,r.jsx)(n.h4,{id:"code-snippets",children:"Code Snippets"}),"\n",(0,r.jsx)(n.p,{children:"Basic inverse kinematics implementation:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'import numpy as np\r\nfrom scipy.optimize import minimize\r\n\r\nclass ManipulatorIK:\r\n    def __init__(self, link_lengths):\r\n        self.link_lengths = link_lengths\r\n        self.n_joints = len(link_lengths)\r\n\r\n    def forward_kinematics(self, joint_angles):\r\n        """\r\n        Compute end-effector position from joint angles (2D planar arm)\r\n        """\r\n        x = 0\r\n        y = 0\r\n        current_angle = 0\r\n\r\n        for i, (length, angle) in enumerate(zip(self.link_lengths, joint_angles)):\r\n            current_angle += angle\r\n            x += length * np.cos(current_angle)\r\n            y += length * np.sin(current_angle)\r\n\r\n        return np.array([x, y])\r\n\r\n    def inverse_kinematics(self, target_pos, initial_guess=None):\r\n        """\r\n        Solve inverse kinematics using numerical optimization\r\n        """\r\n        def objective(joint_angles):\r\n            current_pos = self.forward_kinematics(joint_angles)\r\n            return np.linalg.norm(current_pos - target_pos)**2\r\n\r\n        if initial_guess is None:\r\n            initial_guess = np.zeros(self.n_joints)\r\n\r\n        # Add constraints to keep joint angles within reasonable limits\r\n        bounds = [(-np.pi, np.pi) for _ in range(self.n_joints)]\r\n\r\n        result = minimize(objective, initial_guess, method=\'L-BFGS-B\', bounds=bounds)\r\n\r\n        if result.success:\r\n            return result.x\r\n        else:\r\n            raise ValueError("IK solution not found")\r\n\r\n    def jacobian(self, joint_angles, epsilon=1e-6):\r\n        """\r\n        Compute the Jacobian matrix using finite differences\r\n        """\r\n        n = len(joint_angles)\r\n        jacobian_matrix = np.zeros((2, n))  # 2D position\r\n\r\n        original_pos = self.forward_kinematics(joint_angles)\r\n\r\n        for i in range(n):\r\n            angles_plus = joint_angles.copy()\r\n            angles_plus[i] += epsilon\r\n            pos_plus = self.forward_kinematics(angles_plus)\r\n\r\n            jacobian_matrix[:, i] = (pos_plus - original_pos) / epsilon\r\n\r\n        return jacobian_matrix\r\n\r\n# Example usage\r\narm = ManipulatorIK([0.3, 0.3, 0.2])  # 3-link planar arm with lengths 0.3m, 0.3m, 0.2m\r\ntarget = np.array([0.4, 0.2])\r\ntry:\r\n    solution = arm.inverse_kinematics(target)\r\n    print(f"Found IK solution: {solution}")\r\n    print(f"Actual position: {arm.forward_kinematics(solution)}")\r\n    print(f"Target position: {target}")\r\nexcept ValueError as e:\r\n    print(f"IK solution error: {e}")\n'})}),"\n",(0,r.jsx)(n.h4,{id:"challenge-problems",children:"Challenge Problems"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Implement a grasp planner that can handle objects with unknown geometry by using point cloud data to infer grasp points and orientations"}),"\n",(0,r.jsx)(n.li,{children:"Design a TAMP system that can plan multi-step manipulation tasks while considering both task-level constraints and geometric feasibility"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"senior--executive",children:"Senior / Executive"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Audience"}),": System designer / lead"]}),"\n",(0,r.jsx)(n.h4,{id:"learning-objectives-3",children:"Learning Objectives"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Evaluate manipulation stack architecture options for different robot platforms"}),"\n",(0,r.jsx)(n.li,{children:"Assess trade-offs between data-driven and model-based approaches"}),"\n",(0,r.jsx)(n.li,{children:"Plan for reliability and failure recovery in manipulation systems"}),"\n",(0,r.jsx)(n.li,{children:"Address sim-to-real transfer and dataset challenges"}),"\n",(0,r.jsx)(n.li,{children:"Establish deployment and validation protocols"}),"\n",(0,r.jsx)(n.li,{children:"Balance performance, safety, and computational requirements"}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"manipulation-stack-architecture",children:"Manipulation Stack Architecture"}),"\n",(0,r.jsx)(n.p,{children:"A comprehensive manipulation stack typically includes:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Perception Layer"}),": Object detection, pose estimation, scene understanding"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Knowledge Representation"}),": Object models, spatial relationships, task knowledge"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Grasp Planning"}),": Grasp synthesis, quality evaluation, force optimization"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Motion Planning"}),": Collision-free path planning for reaching and manipulation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Control Layer"}),": Low-level joint control and grasp force regulation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Task Planning"}),": High-level task decomposition and sequencing"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"data-driven-vs-model-based-trade-offs",children:"Data-Driven vs Model-Based Trade-offs"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Data-Driven Approaches"}),": Use machine learning models trained on large datasets to make manipulation decisions. Advantages include handling complex, real-world scenarios. Disadvantages include need for extensive training data and potential lack of interpretability."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Model-Based Approaches"}),": Use physics models and geometric reasoning for manipulation planning. Advantages include interpretability and ability to work in novel scenarios. Disadvantages include sensitivity to modeling inaccuracies."]}),"\n",(0,r.jsx)(n.h4,{id:"reliability-and-failure-modes",children:"Reliability and Failure Modes"}),"\n",(0,r.jsx)(n.p,{children:"Key failure modes in manipulation include:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Grasp Failures"}),": Object slips or falls during grasp"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Collision Failures"}),": Robot collides with objects or environment"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Pose Estimation Errors"}),": Incorrect object pose leads to failed grasp"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Force Control Errors"}),": Too much or too little force applied"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"sim-to-real-and-dataset-concerns",children:"Sim-to-Real and Dataset Concerns"}),"\n",(0,r.jsx)(n.p,{children:"Simulation models rarely match reality perfectly. Key concerns include:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Domain gap between simulation and reality"}),"\n",(0,r.jsx)(n.li,{children:"Need for diverse, real-world training data"}),"\n",(0,r.jsx)(n.li,{children:"Sensor noise and delay not captured in simulation"}),"\n",(0,r.jsx)(n.li,{children:"Physical properties (friction, compliance) differences"}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"deployment-checklist",children:"Deployment Checklist"}),"\n",(0,r.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,r.jsx)(n.strong,{children:"Safety Validation"}),": Are there appropriate safety measures to prevent damage to robot or environment?"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,r.jsx)(n.strong,{children:"Reliability Testing"}),": Has the system been tested under various conditions and failure scenarios?"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,r.jsx)(n.strong,{children:"Calibration Protocol"}),": Are there procedures for maintaining sensor and actuator calibration?"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,r.jsx)(n.strong,{children:"Failure Recovery"}),": How does the system handle and recover from manipulation failures?"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,r.jsx)(n.strong,{children:"Computational Requirements"}),": Does the system meet real-time constraints consistently?"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,r.jsx)(n.strong,{children:"Object Database"}),": Is there an adequate database of objects with known properties and grasp strategies?"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,r.jsx)(n.strong,{children:"Human-Robot Interaction"}),": How does the system handle interaction with humans in shared spaces?"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,r.jsx)(n.strong,{children:"Monitoring Tools"}),": Are there appropriate diagnostics for tracking manipulation performance?"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);